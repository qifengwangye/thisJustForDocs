## 数组的解构赋值
### 基本用法
- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
---
以前的变量命名：
```js
  var x = 1;
  var y = 2;
  var z = 3;
```
现在：
```js
  let [a, b, c] = [1, 2, 3];
```
- 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
- 本质上属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
```js
  let [foo, [[bar], baz]] = [1, [[2], 3]]; // foo: 1, bar: 2, baz: 3
  let [ , , third] = ['foo', 'bar', 'baz']; // third: 'baz'
  let [x, , y] = [1, 2, 3]; // x: 1, y: 3
  let [head, ...tail] = [1, 2, 3, 4]; // head: 1, tail: [2, 3, 4]
  let [x, y, ...z] = ['a']; // x: 'a', y: undefined, z: []
```
- 一旦解构不成功就会返回undefined:
```js
  let [foo] = []; // foo: undefined
  let [bar, foo] = [1]; // bar: 1, foo: undefined
```
- 不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。
```js
  let [x, y] = [1, 2, 3]; // x: 1, y: 2
  let [a, [b], d] = [1, [2, 3], 4]; // a: 1, b: 2, d: 4
  let [a, [...b], d] = [1, [2, 3], 4];  // a: 1, b: [2, 3], d: 4
```
如果等号右边不是数组，或者严格的说是不可便利对象(详见14章)，将会报错;
```js
  let [foo] = 1;
  let [foo] = false;
  let [foo] = NaN;
  let [foo] = undefined;
  let [foo] = null;
  let [foo] = {};
```
上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。
- 对于`set`解构，也能使用数组的解构赋值：
```js
  let [x, y, z] = new Set['a', 'b', 'c'];
```
- 事实上，只要某种数据解构拥有Iterator接口，都可以采用解构赋值：
```js
  function* fibs() {
    let a = 0;
    let b = 1;
    while (true) {
      yield a;
      [a, b] = [b, a + b];
    }
  }

  let [first, second, third, fourth, fifth, sixth] = fibs(); // sixth: 5
```
### 默认值
```js
  let [x, y = 'b'] = ['a']; // x = 'a', y = 'b'
  let [x, y = 'b'] = ['a', undefined]; // x = 'a', y = 'b'
  let [x, y = 'b'] = [undefined, 'a']; // x = undefined, y = 'a'
  let [x = 1] = [null]; // x = null
```
- 注意：ES6内部使用严格相等运算符(===)来判断一个位置是否有值，所以如果一个数组成员不严格等于undefined，默认值不会生效。
- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候才会求值：
```js
  function f() {
    console.log('aaa');
  }

  let [x = f()] = [1]; // x: 1
  let [x = f()] = []; // x: 'aaa'
```
- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
```js
  let [x = 1, y = x] = [];     // x=1; y=1
  let [x = 1, y = x] = [2];    // x=2; y=2
  let [x = 1, y = x] = [1, 2]; // x=1; y=2
  let [x = y, y = 1] = [];     // ReferenceError: y is not defined
  // 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明
```

### 对象的解构赋值
```js
  let { foo, bar } = { foo: "aaa", bar: "bbb" };// foo: 'aaa', bar: 'bbb'
  let { bar, foo } = { foo: "aaa", bar: "bbb" };// foo: 'aaa', bar: 'bbb'
```
- 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
- 如果变量名与属性名不一致，必须写成下面这样:
```js
  let { foo: baz } = { foo: 'aaa', bar: 'bbb' }; // baz: 'aaa'
  ---
  let obj = { first: 'hello', last: 'world' };
  let { first: f, last: l } = obj; // f: 'hello', l: 'world'
```
